# Task 1.8.1: Content Editor Interface

## Story: 1.8 Content Management and Updates
**Priority**: High  
**Estimated Effort**: 3 story points  
**Dependencies**: 1.2 (Content Data Architecture)

## Objective

Create a web-based interface for editing JSON content files with real-time validation and user-friendly form controls.

## Requirements

### Functional Requirements

1. **Form-Based Editor Components**
   - Create editor components for each content type (person, experience, projects, skills)
   - Implement form validation using existing Zod schemas
   - Provide real-time validation feedback
   - Support nested object editing (arrays, complex objects)

2. **Rich Text Editing**
   - Implement rich text editor for description fields
   - Support markdown formatting
   - Add image upload and management
   - Provide preview functionality for formatted content

3. **Auto-Save Functionality**
   - Implement automatic saving of changes
   - Show save status indicators
   - Handle network failures gracefully
   - Provide manual save options

4. **User Interface**
   - Create intuitive form layouts
   - Implement responsive design for mobile editing
   - Add keyboard shortcuts for power users
   - Provide clear field labels and help text

### Technical Requirements

1. **Component Architecture**
   ```typescript
   interface ContentEditorProps {
     contentType: 'person' | 'experience' | 'projects' | 'skills';
     initialData: any;
     onSave: (data: any) => Promise<void>;
     onValidate: (data: any) => ValidationResult;
   }
   ```

2. **Validation Integration**
   ```typescript
   interface ValidationResult {
     isValid: boolean;
     errors: ValidationError[];
     warnings: ValidationWarning[];
   }
   ```

3. **Auto-Save Implementation**
   ```typescript
   interface AutoSaveConfig {
     enabled: boolean;
     interval: number; // milliseconds
     onSave: (data: any) => Promise<void>;
     onError: (error: Error) => void;
   }
   ```

## Implementation Steps

### Step 1: Create Base Editor Components

1. **ContentEditor Component**
   - Create main editor container
   - Implement form state management
   - Add validation integration
   - Set up auto-save functionality

2. **Field Components**
   - TextField component with validation
   - TextArea component for descriptions
   - ArrayField component for lists
   - ObjectField component for nested objects
   - RichTextField component for formatted content

3. **Validation Display**
   - Error message components
   - Warning indicators
   - Field-level validation feedback
   - Form-level validation summary

### Step 2: Implement Rich Text Editing

1. **Rich Text Editor Setup**
   - Integrate markdown editor library
   - Configure toolbar options
   - Add image upload functionality
   - Implement preview mode

2. **Content Formatting**
   - Support markdown syntax
   - Add formatting toolbar
   - Implement link management
   - Add image insertion and editing

### Step 3: Add Auto-Save Functionality

1. **Auto-Save Logic**
   - Implement debounced save function
   - Add save status indicators
   - Handle save conflicts
   - Provide manual save options

2. **Error Handling**
   - Network error recovery
   - Validation error handling
   - Save failure notifications
   - Retry mechanisms

### Step 4: Create User Interface

1. **Form Layout**
   - Responsive grid layout
   - Field grouping and sections
   - Collapsible sections for complex content
   - Mobile-optimized interface

2. **User Experience**
   - Clear field labels and descriptions
   - Help text and tooltips
   - Keyboard navigation support
   - Loading states and feedback

## Technical Implementation

### Component Structure

```typescript
// ContentEditor.tsx
export function ContentEditor({ contentType, initialData, onSave, onValidate }: ContentEditorProps) {
  const [data, setData] = useState(initialData);
  const [validation, setValidation] = useState<ValidationResult>({ isValid: true, errors: [], warnings: [] });
  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved' | 'error'>('idle');

  // Auto-save implementation
  useEffect(() => {
    const timeoutId = setTimeout(async () => {
      if (data !== initialData) {
        setSaveStatus('saving');
        try {
          await onSave(data);
          setSaveStatus('saved');
        } catch (error) {
          setSaveStatus('error');
        }
      }
    }, 2000);

    return () => clearTimeout(timeoutId);
  }, [data, initialData, onSave]);

  // Validation
  useEffect(() => {
    const result = onValidate(data);
    setValidation(result);
  }, [data, onValidate]);

  return (
    <div className="content-editor">
      <ContentEditorHeader contentType={contentType} saveStatus={saveStatus} />
      <ContentEditorForm 
        data={data} 
        onChange={setData} 
        validation={validation}
        contentType={contentType}
      />
      <ContentEditorFooter 
        onSave={() => onSave(data)}
        isValid={validation.isValid}
        errors={validation.errors}
      />
    </div>
  );
}
```

### Field Components

```typescript
// TextField.tsx
export function TextField({ 
  label, 
  value, 
  onChange, 
  error, 
  required = false,
  helpText 
}: TextFieldProps) {
  return (
    <div className="field-container">
      <label className="field-label">
        {label} {required && <span className="required">*</span>}
      </label>
      <input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className={`field-input ${error ? 'error' : ''}`}
        aria-describedby={helpText ? `${label}-help` : undefined}
      />
      {helpText && <div id={`${label}-help`} className="help-text">{helpText}</div>}
      {error && <div className="error-message">{error}</div>}
    </div>
  );
}
```

### Validation Integration

```typescript
// validation.ts
export function validateContent(contentType: string, data: any): ValidationResult {
  const schema = getSchemaForType(contentType);
  
  try {
    schema.parse(data);
    return { isValid: true, errors: [], warnings: [] };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        isValid: false,
        errors: error.errors.map(err => ({
          path: err.path.join('.'),
          message: err.message
        })),
        warnings: []
      };
    }
    return {
      isValid: false,
      errors: [{ path: '', message: 'Unknown validation error' }],
      warnings: []
    };
  }
}
```

## Testing Requirements

### Unit Tests

1. **Component Tests**
   - Test form field components
   - Test validation integration
   - Test auto-save functionality
   - Test error handling

2. **Integration Tests**
   - Test editor with real content data
   - Test save and validation workflows
   - Test user interactions

### E2E Tests

1. **User Workflow Tests**
   - Test complete content editing workflow
   - Test validation error scenarios
   - Test auto-save functionality
   - Test mobile editing experience

## Definition of Done

- [x] Content editor components are created and functional
- [x] Form validation works with existing Zod schemas
- [x] Auto-save functionality is implemented
- [x] Rich text editing is available for description fields
- [x] User interface is responsive and accessible
- [x] All components are tested
- [x] Documentation is updated
- [x] Code is reviewed and approved

## Success Criteria

- Users can edit content without technical knowledge
- Validation errors are displayed clearly and immediately
- Auto-save prevents data loss
- Rich text editing works for formatted content
- Interface is intuitive and responsive

## Dependencies

- Existing Zod schemas for validation
- Content data structure from Story 1.2
- UI component library (shadcn/ui)
- Markdown editor library
- Form state management solution 